{% extends 'base.html' %}

{% block title %}{{ entry.title }}{% endblock %}

{% block content %}
<div class="journal-editor">
    <div class="editor-container">
        <h1>{{ entry.title }}</h1>
        <p><strong>Type:</strong> {{ entry.type }}</p>
        <p><strong>Date:</strong> {{ entry.date_posted.strftime('%Y-%m-%d %H:%M') }}</p>
        {% if entry.mood %}
            <p><strong>Mood:</strong> {{ entry.mood }}</p>
        {% endif %}
        <div class="entry-content" id="journalContentDisplay"
             data-raw-content="{{ entry.content | tojson | default('""', true) }}">
            </div>
        <div class="btn-field">
            <a href="{{ url_for('edit_journal_entry', entry_id=entry.id) }}" class="button">Edit</a>
            <a href="{{ url_for('delete_journal_entry', entry_id=entry.id) }}" class="button delete-button"
               onclick="return confirm('Are you sure you want to delete this entry?')">Delete</a>
            <a href="{{ url_for('dashboard') }}" class="button">Back to Dashboard</a>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const contentDiv = document.getElementById('journalContentDisplay');
        let rawContent = '';

        try {
            // Read the JSON string from the data-raw-content attribute
            // This is safer than directly embedding Jinja into JavaScript
            rawContent = JSON.parse(contentDiv.dataset.rawContent);
        } catch (e) {
            console.error("Error parsing journal content from data attribute:", e);
            // Fallback: If JSON.parse fails, use the raw string from the data attribute directly.
            rawContent = contentDiv.dataset.rawContent;

            // Handle cases where the raw string itself might be "null" or "undefined" as a string
            if (rawContent === "null" || rawContent === "undefined" || rawContent === "") {
                rawContent = "";
            }
        }

        // Ensure rawContent is definitely a string before using string methods
        if (typeof rawContent !== 'string') {
            console.warn("rawContent was not a string after parsing, converting:", rawContent);
            rawContent = String(rawContent);
        }

        // Regular expression to find sketch data placeholders
        const sketchRegex = /\[SKETCH_DATA:(data:image\/[^\]]+?)\]/g;
        // Regular expression to find sticker path placeholders
        const stickerRegex = /\[STICKER_PATH:([^\]]+?)\]/g;

        // First, replace sketch placeholders with actual image tags
        let processedContent = rawContent.replace(sketchRegex, (match, dataURL) => {
            return `<img src="${dataURL}" alt="Sketch" class="embedded-sketch"><br>`;
        });

        // Then, replace sticker placeholders with actual image tags
        processedContent = processedContent.replace(stickerRegex, (match, stickerPath) => {
            return `<img src="${stickerPath}" alt="Sticker" class="embedded-sticker"><br>`;
        });

        // Convert remaining newlines to <br> tags for text
        processedContent = processedContent.replace(/\n/g, '<br>');

        contentDiv.innerHTML = processedContent;
    });
</script>

<style>
    .embedded-sketch {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 10px auto; /* Centered, with spacing */
        border: 1px solid #eee;
        box-shadow: 0 0 5px rgba(0,0,0,0.1);
        border-radius: 4px;
    }
    .embedded-sticker {
        max-width: 100px; /* Adjust size as desired for stickers */
        height: auto;
        display: block;
        margin: 10px auto; /* Centered, with spacing */
        border: 1px solid #ddd;
        box-shadow: 0 0 3px rgba(0,0,0,0.05);
        border-radius: 8px; /* Slightly rounded corners */
        object-fit: contain; /* Ensure sticker fits within max-width/height */
    }
</style>
{% endblock %}